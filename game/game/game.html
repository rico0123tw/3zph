<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>æ°´æœæ¥æ¥æ¨‚ - é—œå¡ç‰ˆ</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; font-family:sans-serif; }
    #gameCanvas { display:block; margin:auto; border:2px solid #333; }
    #score { position:absolute; top:20px; left:50%; transform:translateX(-50%); font-size:24px; font-weight:bold; color:#fff; }
    #restartBtn { position:absolute; top:60px; left:50%; transform:translateX(-50%); font-size:20px; padding:8px 16px; display:none; }
  </style>
</head>
<body>
  <div id="score">åˆ†æ•¸: 0</div>
  <button id="restartBtn">é‡æ–°é–‹å§‹</button>
  <canvas id="gameCanvas" width="500" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score");
    const restartBtn = document.getElementById("restartBtn");

    const bgImg = new Image(); bgImg.src = "è—¥å±€.png";
    const playerImg = new Image(); playerImg.src = "è§’è‰².png";
    const failImg = new Image(); failImg.src = "å¤±æ•—.png";
    const successImg = new Image(); successImg.src = "æˆåŠŸ.png";

    // å®‰å…¨ç‰ˆéŸ³æ•ˆæ’­æ”¾ï¼šç­‰ metadata è¼‰å…¥å¾Œå†è¨­å®š currentTimeï¼Œä¸¦åœ¨ä½¿ç”¨è€…äº’å‹•å¾Œå…è¨±æ’­æ”¾
    function playSoundFrom(src, startTime){
      const sound = new Audio(src);
      sound.addEventListener("loadedmetadata", () => {
        if (Number.isFinite(sound.duration) && startTime < sound.duration && startTime >= 0) {
          sound.currentTime = startTime;
        } else {
          sound.currentTime = 0;
        }
        sound.play().catch(()=>{ /* éœé»˜éŒ¯èª¤ï¼Œé¿å…ä¸­æ–·éŠæˆ² */ });
      });
    }

    let failRatio = 1;
    failImg.onload = () => { failRatio = failImg.width / failImg.height; };
    let successRatio = 1;
    successImg.onload = () => { successRatio = successImg.width / successImg.height; };

    const fruitImgs = {
      "ğŸ": { img: new Image(), score: 1 },
      "ğŸŒ": { img: new Image(), score: 2 },
      "ğŸŠ": { img: new Image(), score: 3 },
      "ğŸ“": { img: new Image(), score: 5 },
      "ğŸ‰": { img: new Image(), bad: true }
    };
    fruitImgs["ğŸ"].img.src = "apple.png";
    fruitImgs["ğŸŒ"].img.src = "banana.png";
    fruitImgs["ğŸŠ"].img.src = "orange.png";
    fruitImgs["ğŸ“"].img.src = "strawberry.png";
    fruitImgs["ğŸ‰"].img.src = "watermelon.png";

    const fruits = ["ğŸ","ğŸŒ","ğŸŠ","ğŸ“"];
    let player, items, score, gameOver, mouseX, spawnInterval;
    let level, fruitCount, speedMultiplier, watermelonChance;
    let paused = true;
    const catchRadius = 30;
    const maxLevel = 10;
    const fruitsPerLevel = 30;

    let floatingTexts = [];
    let facingRight = true;

    // æˆåŠŸç•«é¢æ§åˆ¶
    let showSuccess = false;
    let successTimer = 0;
    let confetti = [];

    function initGame() {
      player = { x:canvas.width/2-60, y:canvas.height-canvas.height/4-20, width:canvas.height/4*0.75, height:canvas.height/4, fail:false };
      items = []; score=0; gameOver=false; level=1; fruitCount=0;
      speedMultiplier=1; watermelonChance=0.2;
      scoreDisplay.textContent="åˆ†æ•¸: 0 | ç¬¬ 1 é—œ | å‰©é¤˜æ°´æœ: " + fruitsPerLevel;
      restartBtn.style.display="none"; mouseX=player.x;
      clearInterval(spawnInterval);
      spawnInterval=setInterval(spawnItem,1000);
      paused=true; update();
    }

    canvas.addEventListener("mousemove", e=>{
      const rect=canvas.getBoundingClientRect();
      mouseX=e.clientX-rect.left-player.width/2;
    });

    // ç¬¬ä¸€æ¬¡é»æ“Šè¦–ç‚ºä½¿ç”¨è€…äº’å‹•ï¼Œä¹‹å¾ŒéŸ³æ•ˆå¯å³æ™‚æ’­æ”¾
    let audioUnlocked = false;
    canvas.addEventListener("click", ()=>{
      if(gameOver) return;
      paused=!paused;
      if(!paused) update();

      if(!audioUnlocked){
        // å˜—è©¦æ’­æ”¾ä¸€å€‹æ¥µçŸ­çš„ç©ºç™½éŸ³æ•ˆä»¥è§£é–ï¼ˆæˆ–ç›´æ¥å»ºç«‹ä¸¦æ’­æ”¾ï¼‰
        const unlock = new Audio();
        unlock.play().catch(()=>{});
        audioUnlocked = true;
      }
    });

    function spawnItem(){
      if(gameOver||paused) return;
      if(fruitCount>=fruitsPerLevel) return;
      const isBad=Math.random()<watermelonChance;
      const fruitKey=isBad?"ğŸ‰":fruits[Math.floor(Math.random()*fruits.length)];
      if(!isBad) fruitCount++;
      items.push({x:Math.random()*(canvas.width-60),y:-60,key:fruitKey,bad:isBad});
      scoreDisplay.textContent="åˆ†æ•¸: "+score+" | ç¬¬ "+level+" é—œ | å‰©é¤˜æ°´æœ: " + (fruitsPerLevel - fruitCount);
    }

    function update(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);
      ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.fillRect(0,0,canvas.width,canvas.height);

      player.x+=(mouseX-player.x)*0.1;
      facingRight = mouseX > player.x;

      ctx.save();
      ctx.translate(player.x+player.width/2, player.y);
      if(facingRight){ ctx.scale(-1,1); }
      if(player.fail){
        const targetHeight = player.height * 4/5;
        const targetWidth = targetHeight * failRatio;
        const offsetY = player.height - targetHeight;
        const offsetX = (player.width - targetWidth) / 2;
        ctx.drawImage(failImg,-player.width/2+offsetX,offsetY,targetWidth,targetHeight);
      } else {
        ctx.drawImage(playerImg,-player.width/2,0,player.width,player.height);
      }
      ctx.restore();

      if(gameOver){
        ctx.fillStyle="#fff"; ctx.font="28px sans-serif"; ctx.textAlign="center";
        ctx.fillText("éŠæˆ²çµæŸ! æœ€çµ‚åˆ†æ•¸: "+score,canvas.width/2,canvas.height/2-20);
        ctx.fillText("å¤šåƒæ°´æœ, ä¸‰èŠè—¥å¸«è—¥å±€é—œå¿ƒæ‚¨",canvas.width/2,canvas.height/2+20);
        return;
      }

      if(paused){
        if(showSuccess && successTimer > 0){
          const targetHeight = canvas.height * 0.75; 
          const targetWidth = targetHeight * successRatio; 
          const centerX = canvas.width / 2; 
          const offsetX = centerX - targetWidth / 2; 
          const offsetY = canvas.height - targetHeight; 
          ctx.drawImage(successImg, offsetX, offsetY, targetWidth, targetHeight);

          confetti.forEach(c=>{
            ctx.fillStyle = c.color;
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.size, 0, Math.PI*2);
            ctx.fill();
            c.y += c.speed;
            c.x += Math.sin(c.y/20)*2;
          });
          confetti = confetti.filter(c => c.y < canvas.height+20);

          successTimer--;
          if(successTimer <= 0){
            showSuccess = false;
          }
          requestAnimationFrame(update);
          return;
        }

        ctx.fillStyle="rgba(0,0,0,0.7)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="#fff"; ctx.font="20px sans-serif"; ctx.textAlign="center";
        ctx.fillText("éŠæˆ²æš«åœ",canvas.width/2,canvas.height/2-60);
        ctx.fillText("è¦å‰‡ï¼š",canvas.width/2,canvas.height/2-30);
        ctx.fillText("æ¯é—œæ‰è½ 30 é¡†æ°´æœ (ä¸å«è¥¿ç“œ)",canvas.width/2,canvas.height/2);
        ctx.fillText("æ¼æ¥æ°´æœæœƒæ‰£åˆ†ï¼Œæœ€ä½ 0 åˆ†",canvas.width/2,canvas.height/2+30);
        ctx.fillText("æ¥åˆ°æ°´æœé¡¯ç¤ºåŠ åˆ†æ–‡å­—",canvas.width/2,canvas.height/2+60);
        ctx.fillText("é»æ“Šæ»‘é¼ ç¹¼çºŒéŠæˆ²",canvas.width/2,canvas.height/2+90);
        return;
      }

      items.forEach(item=>{
        item.y+=Math.min(10*speedMultiplier,(4+score*0.05)*speedMultiplier);
        const fruitData=fruitImgs[item.key];
        ctx.drawImage(fruitData.img,item.x,item.y,60,60);

        const playerCenterX=player.x+player.width/2;
        const playerCenterY=player.y+player.height/2;
        const fruitCenterX=item.x+30;
        const fruitCenterY=item.y+30;
        const dx=playerCenterX-fruitCenterX, dy=playerCenterY-fruitCenterY;
        const distance=Math.sqrt(dx*dx+dy*dy);

        if(distance<catchRadius){
          if(item.bad){ 
            playSoundFrom("è¥¿ç“œç ¸åˆ°.m4a", 0.5); // æ’­æ”¾è¥¿ç“œç ¸åˆ°éŸ³æ•ˆ
            endGame(); 
          } else {
            score+=fruitData.score;
            playSoundFrom("åƒæ°´æœ.m4a", 0.9);   // è·³éå‰é¢ 0.8 ç§’æ’­æ”¾
            showFloatingText("+"+fruitData.score,"lime",fruitCenterX,fruitCenterY);
            scoreDisplay.textContent="åˆ†æ•¸: "+score+" | ç¬¬ "+level+" é—œ | å‰©é¤˜æ°´æœ: " + (fruitsPerLevel - fruitCount);
          }
          items = items.filter(f => f !== item);
        }
      });

      // æ¼æ¥æ°´æœ â†’ æ‰£åˆ†
      items.forEach(item=>{ 
        if(!item.bad && item.y > canvas.height){ 
          let deduct = fruitImgs[item.key].score; 
          if(score - deduct < 0){ deduct = score; }
          score -= deduct; 
          showFloatingText("-"+deduct,"red",item.x+30,canvas.height-30); 
          scoreDisplay.textContent = "åˆ†æ•¸: " + score + " | ç¬¬ " + level + " é—œ | å‰©é¤˜æ°´æœ: " + (fruitsPerLevel - fruitCount);
          items = items.filter(f => f !== item);
        } 
      });

      items = items.filter(item => item.y < canvas.height + 50);

      // åˆ¤æ–·éé—œ
      if(fruitCount >= fruitsPerLevel && items.length === 0){
        if(level < maxLevel){
          level++;
          fruitCount = 0;
          speedMultiplier *= 1.1;
          watermelonChance *= 1.1;
          scoreDisplay.textContent = 
            "åˆ†æ•¸: " + score + " | ç¬¬ " + level + " é—œ | å‰©é¤˜æ°´æœ: " + fruitsPerLevel;
          paused = true;

          // æ’­æ”¾é€šé—œéŸ³æ•ˆ
          playSoundFrom("é€šé—œ.m4a", 0.0);

          // é¡¯ç¤ºæˆåŠŸç•«é¢ 3 ç§’
          showSuccess = true;
          successTimer = 180; // ç´„ 3 ç§’ (60fps)
          confetti = [];
          for(let i=0;i<50;i++){
            confetti.push({
              x: Math.random()*canvas.width,
              y: Math.random()*-canvas.height/2,
              size: 5+Math.random()*5,
              speed: 2+Math.random()*3,
              color: `hsl(${Math.random()*360},100%,50%)`
            });
          }
        } else {
          endGame();
        }
      }

      // é¡¯ç¤ºæµ®å‹•åˆ†æ•¸æ–‡å­—
      floatingTexts.forEach(ft=>{
        ctx.globalAlpha = ft.alpha;
        ctx.fillStyle = ft.color;
        ctx.font = "30px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1.0;

        ft.y -= 1;       // å‘ä¸Šé£„
        ft.alpha -= 0.03; // æ¼¸æ¼¸æ·¡å‡º
      });
      floatingTexts = floatingTexts.filter(ft => ft.alpha > 0);

      requestAnimationFrame(update);
    }

    function showFloatingText(text,color,x,y){
      floatingTexts.push({
        text:text,
        color:color,
        x:x,
        y:y,
        alpha:1
      });
    }

    function endGame(){
      gameOver = true;
      player.fail = true;
      restartBtn.style.display = "block";
    }

    restartBtn.addEventListener("click", initGame);

    initGame();
  </script>
</body>
</html>
